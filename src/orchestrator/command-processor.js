const GoogleCalendarAPI = require('../api/google-calendar-api');
const TickTickAPI = require('../api/ticktick-api');
const AirtableAPI = require('../api/airtable-api');
const CalendarCleaner = require('./calendar-cleaner');
const logger = require('../utils/logger');
const config = require('../config/config');

class CommandProcessor {
  constructor() {
    this.googleCalendar = new GoogleCalendarAPI();
    this.ticktick = new TickTickAPI();
    this.airtable = new AirtableAPI();
    this.cleaner = new CalendarCleaner();

    // Historique des actions pour UNDO
    this.actionHistory = [];
    this.maxHistorySize = 50;
  }

  async initialize() {
    try {
      await this.googleCalendar.loadTokens();
      await this.ticktick.loadTokens();
      await this.airtable.initialize();
      await this.cleaner.initialize();

      logger.info('CommandProcessor initialis√© avec succ√®s');
      return true;
    } catch (error) {
      logger.error('Erreur lors de l\'initialisation du CommandProcessor:', error.message);
      return false;
    }
  }

  // === TRAITEMENT COMMANDE EN LANGAGE NATUREL ===

  async processCommand(command) {
    try {
      const normalizedCommand = command.toLowerCase().trim();

      logger.info(`üìù Commande re√ßue: "${command}"`);

      // D√©tecter le type de commande
      const commandType = this.detectCommandType(normalizedCommand);

      let result = null;

      switch (commandType.type) {
        case 'delete':
          result = await this.handleDelete(normalizedCommand, commandType);
          break;

        case 'cleanup':
          result = await this.handleCleanup(normalizedCommand);
          break;

        case 'undo':
          result = await this.handleUndo();
          break;

        case 'move':
          result = await this.handleMove(normalizedCommand, commandType);
          break;

        case 'postpone':
          result = await this.handlePostpone(normalizedCommand, commandType);
          break;

        case 'create':
          result = await this.handleCreate(normalizedCommand, commandType);
          break;

        case 'complete':
          result = await this.handleComplete(normalizedCommand, commandType);
          break;

        case 'search':
          result = await this.handleSearch(normalizedCommand, commandType);
          break;

        case 'block':
          result = await this.handleBlock(normalizedCommand, commandType);
          break;

        case 'priority':
          result = await this.handlePriority(normalizedCommand, commandType);
          break;

        case 'relance':
          result = await this.handleRelance(normalizedCommand, commandType);
          break;

        case 'suggest':
          result = await this.handleSuggest(normalizedCommand);
          break;

        default:
          result = {
            success: false,
            message: 'Commande non reconnue. Tapez "aide" pour voir les commandes disponibles.',
            suggestions: this.getSuggestions(normalizedCommand)
          };
      }

      // Sauvegarder dans l'historique (sauf undo et search)
      if (result.success && commandType.type !== 'undo' && commandType.type !== 'search') {
        this.saveToHistory({
          command,
          type: commandType.type,
          result,
          timestamp: new Date()
        });
      }

      return result;

    } catch (error) {
      logger.error('Erreur lors du traitement de la commande:', error.message);
      return {
        success: false,
        message: `Erreur: ${error.message}`
      };
    }
  }

  // === D√âTECTION TYPE DE COMMANDE ===

  detectCommandType(command) {
    // Supprimer / Effacer / Delete
    if (command.match(/supprime|efface|delete|retire|enl√®ve|vire/)) {
      return {
        type: 'delete',
        target: this.extractTarget(command)
      };
    }

    // Nettoyer / Clean
    if (command.match(/nettoie|clean|purge|range/)) {
      return { type: 'cleanup' };
    }

    // Annuler / Undo
    if (command.match(/annule|undo|retour|revenir|annuler/)) {
      return { type: 'undo' };
    }

    // D√©placer / Move
    if (command.match(/d√©place|bouge|move|change.*heure|change.*date/)) {
      return {
        type: 'move',
        target: this.extractTarget(command),
        when: this.extractWhen(command)
      };
    }

    // Reporter / Postpone
    if (command.match(/reporte|d√©cale|postpone|plus tard|demain|semaine prochaine/)) {
      return {
        type: 'postpone',
        target: this.extractTarget(command),
        delay: this.extractDelay(command)
      };
    }

    // Cr√©er / Add
    if (command.match(/cr√©e|ajoute|cr√©er|add|nouveau|nouvelle/)) {
      return {
        type: 'create',
        what: this.extractWhat(command),
        when: this.extractWhen(command)
      };
    }

    // Terminer / Complete
    if (command.match(/termine|fini|compl√®te|marque.*termin√©|done/)) {
      return {
        type: 'complete',
        target: this.extractTarget(command)
      };
    }

    // Rechercher / Search
    if (command.match(/cherche|trouve|search|liste|affiche/)) {
      return {
        type: 'search',
        query: this.extractQuery(command)
      };
    }

    // Bloquer cr√©neau / Block
    if (command.match(/bloque|r√©serve|focus|concentration/)) {
      return {
        type: 'block',
        when: this.extractWhen(command),
        duration: this.extractDuration(command)
      };
    }

    // Priorit√©
    if (command.match(/priorit√©|urgent|important/)) {
      return {
        type: 'priority',
        target: this.extractTarget(command),
        level: this.extractPriorityLevel(command)
      };
    }

    // Relancer prospect
    if (command.match(/relance|rappel|contact.*prospect|appel/)) {
      return {
        type: 'relance',
        target: this.extractTarget(command)
      };
    }

    // Sugg√©rer / Suggest
    if (command.match(/sugg√®re|propose|optimise|r√©organise|am√©liore/)) {
      return { type: 'suggest' };
    }

    return { type: 'unknown' };
  }

  // === HANDLERS ===

  async handleDelete(command, commandType) {
    const target = commandType.target;

    if (!target) {
      return {
        success: false,
        message: 'Veuillez pr√©ciser ce que vous voulez supprimer (ex: "supprime la t√¢che X")'
      };
    }

    // D√©terminer si c'est TickTick ou Google Calendar
    const isTickTick = command.includes('t√¢che') || command.includes('ticktick');
    const isGoogleCal = command.includes('√©v√©nement') || command.includes('agenda') || command.includes('calendar');

    let deleted = [];

    // Chercher dans TickTick
    if (isTickTick || !isGoogleCal) {
      const tasks = await this.ticktick.getTasks();
      const matchingTasks = tasks.filter(task =>
        task.title.toLowerCase().includes(target.toLowerCase())
      );

      for (const task of matchingTasks) {
        await this.ticktick.deleteTask(task.id);
        deleted.push({ type: 'ticktick', item: task });
        logger.info(`T√¢che TickTick supprim√©e: "${task.title}"`);
      }
    }

    // Chercher dans Google Calendar
    if (isGoogleCal || !isTickTick) {
      const calendarIds = [config.calendars.jeremy, config.calendars.business];
      const now = new Date();
      const endDate = new Date(now);
      endDate.setDate(endDate.getDate() + 30);

      for (const calendarId of calendarIds) {
        const events = await this.googleCalendar.getEvents(calendarId, now, endDate);
        const matchingEvents = events.filter(event =>
          (event.summary || '').toLowerCase().includes(target.toLowerCase())
        );

        for (const event of matchingEvents) {
          await this.googleCalendar.deleteEvent(calendarId, event.id);
          deleted.push({ type: 'calendar', calendarId, item: event });
          logger.info(`√âv√©nement Google Calendar supprim√©: "${event.summary}"`);
        }
      }
    }

    if (deleted.length === 0) {
      return {
        success: false,
        message: `Aucun √©l√©ment trouv√© correspondant √† "${target}"`
      };
    }

    return {
      success: true,
      message: `${deleted.length} √©l√©ment(s) supprim√©(s)`,
      deleted,
      undoable: true
    };
  }

  async handleCleanup(command) {
    logger.info('üßπ Nettoyage manuel d√©clench√© via commande');

    const report = await this.cleaner.performCleanup();

    return {
      success: true,
      message: `Nettoyage termin√© - ${report.fixed} corrections effectu√©es`,
      report
    };
  }

  async handleUndo() {
    if (this.actionHistory.length === 0) {
      return {
        success: false,
        message: 'Aucune action √† annuler'
      };
    }

    const lastAction = this.actionHistory.pop();

    logger.info(`‚èÆÔ∏è Annulation de l'action: ${lastAction.type}`);

    // Annuler selon le type
    if (lastAction.type === 'delete' && lastAction.result.deleted) {
      // Recr√©er les √©l√©ments supprim√©s
      for (const item of lastAction.result.deleted) {
        if (item.type === 'ticktick') {
          // Recr√©er la t√¢che TickTick
          await this.ticktick.createTask({
            title: item.item.title,
            content: item.item.content,
            dueDate: item.item.dueDate,
            priority: item.item.priority
          });
        } else if (item.type === 'calendar') {
          // Recr√©er l'√©v√©nement Google Calendar
          await this.googleCalendar.createEvent(item.calendarId, {
            summary: item.item.summary,
            description: item.item.description,
            start: item.item.start,
            end: item.item.end
          });
        }
      }

      return {
        success: true,
        message: `Action annul√©e - ${lastAction.result.deleted.length} √©l√©ment(s) restaur√©(s)`
      };
    }

    return {
      success: false,
      message: 'Cette action ne peut pas √™tre annul√©e'
    };
  }

  async handleMove(command, commandType) {
    // TODO: Impl√©menter d√©placement
    return {
      success: false,
      message: 'Fonctionnalit√© "d√©placer" en cours de d√©veloppement'
    };
  }

  async handlePostpone(command, commandType) {
    // TODO: Impl√©menter report
    return {
      success: false,
      message: 'Fonctionnalit√© "reporter" en cours de d√©veloppement'
    };
  }

  async handleCreate(command, commandType) {
    // TODO: Impl√©menter cr√©ation rapide
    return {
      success: false,
      message: 'Fonctionnalit√© "cr√©er" en cours de d√©veloppement'
    };
  }

  async handleComplete(command, commandType) {
    // TODO: Impl√©menter marquage termin√©
    return {
      success: false,
      message: 'Fonctionnalit√© "terminer" en cours de d√©veloppement'
    };
  }

  async handleSearch(command, commandType) {
    // TODO: Impl√©menter recherche
    return {
      success: false,
      message: 'Fonctionnalit√© "rechercher" en cours de d√©veloppement'
    };
  }

  async handleBlock(command, commandType) {
    // TODO: Impl√©menter blocage cr√©neau
    return {
      success: false,
      message: 'Fonctionnalit√© "bloquer cr√©neau" en cours de d√©veloppement'
    };
  }

  async handlePriority(command, commandType) {
    // TODO: Impl√©menter changement priorit√©
    return {
      success: false,
      message: 'Fonctionnalit√© "priorit√©" en cours de d√©veloppement'
    };
  }

  async handleRelance(command, commandType) {
    // TODO: Impl√©menter relance prospect
    return {
      success: false,
      message: 'Fonctionnalit√© "relance" en cours de d√©veloppement'
    };
  }

  async handleSuggest(command) {
    // TODO: Impl√©menter suggestions IA
    return {
      success: false,
      message: 'Fonctionnalit√© "suggestions" en cours de d√©veloppement'
    };
  }

  // === EXTRACTION DE DONN√âES ===

  extractTarget(command) {
    // Extraire le nom de la t√¢che/√©v√©nement
    const patterns = [
      /(?:t√¢che|√©v√©nement|event|task)\s+["']?(.+?)["']?(?:\s|$)/i,
      /["'](.+?)["']/,
      /(?:appel√©e?|nomm√©e?)\s+(.+)/i
    ];

    for (const pattern of patterns) {
      const match = command.match(pattern);
      if (match) return match[1].trim();
    }

    // Fallback: prendre le dernier mot/groupe
    const words = command.split(' ');
    return words[words.length - 1];
  }

  extractWhen(command) {
    if (command.includes('demain')) return 'tomorrow';
    if (command.includes('semaine prochaine')) return 'next_week';
    if (command.includes('mois prochain')) return 'next_month';
    return null;
  }

  extractDelay(command) {
    if (command.includes('demain')) return { days: 1 };
    if (command.includes('semaine')) return { days: 7 };
    if (command.includes('mois')) return { days: 30 };
    return { days: 1 };
  }

  extractWhat(command) {
    // TODO: Extraire ce qu'on veut cr√©er
    return null;
  }

  extractQuery(command) {
    // TODO: Extraire la requ√™te de recherche
    return null;
  }

  extractDuration(command) {
    const match = command.match(/(\d+)\s*(heure|h|minute|min)/i);
    if (match) {
      const value = parseInt(match[1]);
      const unit = match[2].toLowerCase();
      return unit.startsWith('h') ? value * 60 : value;
    }
    return 60; // 1h par d√©faut
  }

  extractPriorityLevel(command) {
    if (command.includes('urgent') || command.includes('critique')) return 'high';
    if (command.includes('important')) return 'medium';
    if (command.includes('faible') || command.includes('basse')) return 'low';
    return 'medium';
  }

  getSuggestions(command) {
    return [
      'Supprime la t√¢che "Nom de la t√¢che"',
      'Nettoie l\'agenda',
      'Annule la derni√®re action',
      'D√©place l\'√©v√©nement "X" √† demain',
      'Reporte la t√¢che "Y" √† la semaine prochaine'
    ];
  }

  // === HISTORIQUE ===

  saveToHistory(action) {
    this.actionHistory.push(action);

    // Limiter la taille de l'historique
    if (this.actionHistory.length > this.maxHistorySize) {
      this.actionHistory.shift();
    }
  }

  getHistory(limit = 10) {
    return this.actionHistory.slice(-limit).reverse();
  }

  // === AIDE ===

  getHelpText() {
    return `
ü§ñ COMMANDES DISPONIBLES:

üìù GESTION T√ÇCHES/√âV√âNEMENTS:
‚Ä¢ "Supprime la t√¢che X" - Supprimer une t√¢che
‚Ä¢ "Supprime l'√©v√©nement Y dans l'agenda" - Supprimer √©v√©nement
‚Ä¢ "Termine la t√¢che Z" - Marquer comme termin√©
‚Ä¢ "Cherche la t√¢che A" - Rechercher

üîÑ ORGANISATION:
‚Ä¢ "D√©place l'√©v√©nement X √† demain" - D√©placer
‚Ä¢ "Reporte la t√¢che Y √† la semaine prochaine" - Reporter
‚Ä¢ "Nettoie l'agenda" - Nettoyage automatique

‚èÆÔ∏è ANNULATION:
‚Ä¢ "Annule" - Annuler la derni√®re action

üéØ CR√âATION RAPIDE:
‚Ä¢ "Cr√©e une t√¢che X demain √† 14h"
‚Ä¢ "Bloque 2h cet apr√®s-midi pour focus"

üìä CRM CAP NUM√âRIQUE:
‚Ä¢ "Relance le prospect X"
‚Ä¢ "Liste les prospects √† relancer"

üí° SUGGESTIONS:
‚Ä¢ "Sugg√®re une r√©organisation"
‚Ä¢ "Optimise ma journ√©e"

üîç RECHERCHE:
‚Ä¢ "Trouve toutes les t√¢ches urgentes"
‚Ä¢ "Affiche mon agenda de demain"
    `.trim();
  }
}

module.exports = CommandProcessor;
