const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const path = require('path');
const https = require('https');
const http = require('http');
const fs = require('fs');

const config = require('./config/config');
const logger = require('./utils/logger');

// Routes
const authRoutes = require('./web/routes/auth');
const taskRoutes = require('./web/routes/tasks');
const calendarRoutes = require('./web/routes/calendar');
const schedulerRoutes = require('./web/routes/scheduler');
const apiRoutes = require('./web/routes/api');

// Middleware d'authentification
const { authenticateToken } = require('./web/middleware/auth');

class OrchestratorApp {
  constructor() {
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
    this.setupErrorHandling();
  }

  setupMiddleware() {
    // S√©curit√©
    this.app.use(helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
          scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
          imgSrc: ["'self'", "data:", "https:"],
          connectSrc: ["'self'", "https://api.ticktick.com", "https://www.googleapis.com"]
        }
      }
    }));

    // CORS
    this.app.use(cors({
      origin: config.server.env === 'development' ? '*' : false,
      credentials: true
    }));

    // Rate limiting
    const limiter = rateLimit({
      windowMs: config.security.rateLimitWindow,
      max: config.security.rateLimitMax,
      message: {
        error: 'Trop de requ√™tes, veuillez r√©essayer plus tard'
      }
    });
    this.app.use('/api', limiter);

    // Body parsing
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

    // Logging des requ√™tes
    this.app.use((req, res, next) => {
      logger.info(`${req.method} ${req.path} - ${req.ip}`);
      next();
    });
  }

  setupRoutes() {
    // Routes d'authentification (publiques)
    this.app.use('/auth', authRoutes);

    // Routes de configuration (prot√©g√©es)
    const configRoutes = require('./web/routes/config');
    this.app.use('/api/config', authenticateToken, configRoutes);

    // Interface web (PROT√âG√âE - redirection vers login si non authentifi√©)
    this.app.get('/', (req, res) => {
      // Toujours rediriger vers login - l'authentification se fait c√¥t√© client
      res.redirect('/login');
    });

    // Page de login (publique)
    this.app.get('/login', (req, res) => {
      res.sendFile(path.join(__dirname, 'web/public/login.html'));
    });

    // Dashboard (prot√©g√©)
    this.app.get('/dashboard', (req, res) => {
      // V√©rifier si l'utilisateur est authentifi√©
      const token = req.headers.authorization?.split(' ')[1] || req.query.token;

      if (!token) {
        return res.redirect('/login');
      }

      // V√©rifier la validit√© du token
      const jwt = require('jsonwebtoken');
      const config = require('./config/config');

      try {
        jwt.verify(token, config.security.jwtSecret);
        res.sendFile(path.join(__dirname, 'web/public/index.html'));
      } catch (error) {
        res.redirect('/login?error=expired');
      }
    });

    // Page de configuration (prot√©g√©e)
    this.app.get('/config', (req, res) => {
      // V√©rifier si l'utilisateur est authentifi√©
      const token = req.headers.authorization?.split(' ')[1] || req.query.token;

      if (!token) {
        return res.redirect('/login');
      }

      // V√©rifier la validit√© du token
      const jwt = require('jsonwebtoken');
      const config = require('./config/config');

      try {
        jwt.verify(token, config.security.jwtSecret);
        res.sendFile(path.join(__dirname, 'web/public/config.html'));
      } catch (error) {
        res.redirect('/login');
      }
    });

    // Health check (public)
    this.app.get('/health', (req, res) => {
      res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        version: '1.0.0',
        environment: config.server.env
      });
    });

    // Fichiers statiques publics (uniquement CSS, JS, images)
    this.app.use('/css', express.static(path.join(__dirname, 'web/public/css')));
    this.app.use('/js', express.static(path.join(__dirname, 'web/public/js')));
    this.app.use('/img', express.static(path.join(__dirname, 'web/public/img')));
    this.app.use('/assets', express.static(path.join(__dirname, 'web/public/assets')));

    // Servir les fichiers JS/CSS de l'app seulement
    this.app.get('/app.js', (req, res) => {
      res.sendFile(path.join(__dirname, 'web/public/app.js'));
    });
    this.app.get('/config.js', (req, res) => {
      res.sendFile(path.join(__dirname, 'web/public/config.js'));
    });

    // Routes API prot√©g√©es
    this.app.use('/api/tasks', authenticateToken, taskRoutes);
    this.app.use('/api/calendar', authenticateToken, calendarRoutes);
    this.app.use('/api/scheduler', authenticateToken, schedulerRoutes);
    this.app.use('/api', authenticateToken, apiRoutes);

    // Route catch-all - rediriger vers login
    this.app.get('*', (req, res) => {
      if (req.path.startsWith('/api')) {
        return res.status(404).json({ error: 'Endpoint non trouv√©' });
      }
      // Toutes les autres routes redirigent vers login
      res.redirect('/login');
    });
  }

  setupErrorHandling() {
    // Gestionnaire d'erreurs 404
    this.app.use((req, res, next) => {
      res.status(404).json({
        error: 'Ressource non trouv√©e',
        path: req.path,
        method: req.method
      });
    });

    // Gestionnaire d'erreurs global
    this.app.use((error, req, res, next) => {
      logger.error('Erreur non g√©r√©e:', error);

      // Ne pas exposer les d√©tails en production
      const isDevelopment = config.server.env === 'development';

      res.status(error.status || 500).json({
        error: isDevelopment ? error.message : 'Erreur interne du serveur',
        ...(isDevelopment && { stack: error.stack }),
        timestamp: new Date().toISOString(),
        path: req.path
      });
    });
  }

  async start() {
    try {
      const port = config.server.port;
      const httpsPort = config.server.httpsPort;

      // V√©rifier la configuration
      if (config.server.env === 'production') {
        this.validateProductionConfig();
      }

      // Serveur HTTP (redirection vers HTTPS)
      const httpApp = express();
      httpApp.use((req, res) => {
        const httpsUrl = `https://${req.headers.host.replace(/:\d+$/, '')}:${httpsPort}${req.url}`;
        res.redirect(301, httpsUrl);
      });

      this.httpServer = http.createServer(httpApp);
      this.httpServer.listen(port, () => {
        logger.info(`üîÑ Serveur HTTP d√©marr√© sur le port ${port} (redirection HTTPS)`);
      });

      // Serveur HTTPS
      try {
        const sslOptions = {
          key: fs.readFileSync(path.join(__dirname, '..', config.server.sslKeyPath)),
          cert: fs.readFileSync(path.join(__dirname, '..', config.server.sslCertPath))
        };

        this.httpsServer = https.createServer(sslOptions, this.app);
        this.httpsServer.listen(httpsPort, () => {
          logger.info(`üöÄ TickTick Orchestrator d√©marr√© sur le port HTTPS ${httpsPort}`);
          logger.info(`üåê Interface web: https://localhost:${httpsPort}`);
          logger.info(`üìã API: https://localhost:${httpsPort}/api`);
          logger.info(`üîß Environnement: ${config.server.env}`);
          logger.info(`üîí SSL activ√© avec certificat auto-sign√©`);
        });

        this.server = this.httpsServer;
      } catch (sslError) {
        logger.warn('Certificats SSL non trouv√©s, d√©marrage HTTP uniquement:', sslError.message);

        // Fallback vers HTTP si SSL √©choue
        this.server = this.app.listen(port, () => {
          logger.info(`üöÄ TickTick Orchestrator d√©marr√© sur le port ${port} (HTTP uniquement)`);
          logger.info(`üåê Interface web: http://localhost:${port}`);
          logger.info(`üìã API: http://localhost:${port}/api`);
          logger.info(`üîß Environnement: ${config.server.env}`);
        });
      }

      // Gestion propre de l'arr√™t
      process.on('SIGTERM', () => this.gracefulShutdown('SIGTERM'));
      process.on('SIGINT', () => this.gracefulShutdown('SIGINT'));

      return this.server;
    } catch (error) {
      logger.error('Erreur lors du d√©marrage du serveur:', error.message);
      throw error;
    }
  }

  validateProductionConfig() {
    const required = [
      'TICKTICK_CLIENT_ID',
      'TICKTICK_CLIENT_SECRET',
      'GOOGLE_CLIENT_ID',
      'GOOGLE_CLIENT_SECRET',
      'JWT_SECRET'
    ];

    const missing = required.filter(key => !process.env[key]);

    if (missing.length > 0) {
      throw new Error(`Variables d'environnement manquantes en production: ${missing.join(', ')}`);
    }

    if (config.security.jwtSecret === 'default-secret-change-in-production') {
      throw new Error('JWT_SECRET doit √™tre chang√© en production');
    }

    if (config.security.adminPassword === 'admin123') {
      throw new Error('ADMIN_PASSWORD doit √™tre chang√© en production');
    }
  }

  async gracefulShutdown(signal) {
    logger.info(`Signal ${signal} re√ßu, arr√™t en cours...`);

    // Fermer les serveurs HTTP et HTTPS
    const promises = [];

    if (this.httpServer) {
      promises.push(new Promise((resolve) => {
        this.httpServer.close(() => {
          logger.info('Serveur HTTP ferm√©');
          resolve();
        });
      }));
    }

    if (this.httpsServer) {
      promises.push(new Promise((resolve) => {
        this.httpsServer.close(() => {
          logger.info('Serveur HTTPS ferm√©');
          resolve();
        });
      }));
    }

    if (this.server && this.server !== this.httpsServer) {
      promises.push(new Promise((resolve) => {
        this.server.close(() => {
          logger.info('Serveur principal ferm√©');
          resolve();
        });
      }));
    }

    // Attendre que tous les serveurs se ferment
    try {
      await Promise.all(promises);
      logger.info('Tous les serveurs ferm√©s proprement');
      process.exit(0);
    } catch (error) {
      logger.error('Erreur lors de la fermeture:', error);
      setTimeout(() => {
        logger.info('Arr√™t forc√©');
        process.exit(0);
      }, 5000);
    }
  }

  // M√©thodes utilitaires pour les tests
  getApp() {
    return this.app;
  }

  async stop() {
    if (this.server) {
      return new Promise((resolve) => {
        this.server.close(resolve);
      });
    }
  }
}

// D√©marrage automatique si ex√©cut√© directement
if (require.main === module) {
  const app = new OrchestratorApp();

  app.start().catch(error => {
    logger.error('Erreur fatale:', error.message);
    process.exit(1);
  });
}

module.exports = OrchestratorApp;